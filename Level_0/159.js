/**
 * [등수 매기기]
 * 
 * 영어 점수와 수학 점수의 평균 점수를 기준으로 학생들의 등수를 매기려고 합니다. 
 * 영어 점수와 수학 점수를 담은 2차원 정수 배열 score가 주어질 때, 
 * 영어 점수와 수학 점수의 평균을 기준으로 매긴 등수를 담은 배열을 return하도록 solution 함수를 완성해주세요.
 */

const solution = (score) => {
    const scoreRank = score.map(([a, b]) => a + b).sort((a,b) => b - a);
    let avgArr = score.map(([a, b]) => [0, a+b]);
    let rank = 1;

    for(i = 0; i < scoreRank.length; i++) {
        avgArr = avgArr.map(([r, n]) => n === scoreRank[i] ? [rank, n] : [r, n]);
        if(i !== scoreRank.length && scoreRank[i] !== scoreRank[i+1]) rank += scoreRank.filter(n => n ===scoreRank[i]).length;
    }

    return avgArr.map(([r,_]) => r);
}

// sort의 경우 인스턴스를 리턴하는 것이 아닌 직접 메모리의 값을 수정하므로
// 사용할 경우 원본도 변화가 생김.
// 하지만 slice함수를 추가함으로서 복사본을 만들고 정렬할 수 있게됨.
// 다른 방법으로 배열의 복사하고 싶을 때는 스프레드 전개법으로 복사할 수 있음. ex) [...a].sort((a,b) => a - b);
// indexOf로 찾는다고 하여도 맨 앞에 있는 요소를 찾기 때문에 공동등수로 낼 수 있음.
const solution2 = (score) => {
    const avg = score.map(([a,b]) => a + b);
    const sorted = avg.slice().sort((a,b) => b - a);
    return avg.map(n => sorted.indexOf(n) + 1);
}

// 한 줄로 한다면, 이렇게 할 수 있겠지만 연산량이 많아서 원소가 많아지면 많아질수록 효율은 떨어짐.
const solution3 = score => score.map(([a,b]) => a + b).map((n,_,r) => [...r].sort((a,b) => b - a).indexOf(n) + 1);

// 내부요소를 이중for문 형식으로 하나하나 비교하는 방식
// 본인보다 위에 있는 수만큼의 양이 곧 등수를 나타내기 때문
// ex) 1등 위에는 아무것도 없고 (=0), 2등 위에는 한 명이 있고 (=1)
// 하지만 n2이기 때문에 효율은 좋지 못할 줄 알았으나, 가장 효율이 좋음.
const solution4 = score => score.map(el => score.filter(v => (v[0] + v[1]) / 2 > (el[0] + el[1]) / 2).length + 1);

console.time();
console.log(solution([[1, 1], [2, 1], [3, 1], [4, 1], [5, 1], [6, 1], [7, 1], [8, 1], [9, 1], [0, 0]]));	// [1, 2, 4, 3]
console.log(solution([[80, 70], [90, 50], [40, 70], [50, 80]]));	// [1, 2, 4, 3]
console.log(solution([[80, 70], [70, 80], [30, 50], [90, 100], [100, 90], [100, 100], [10, 30]]));	// [4, 4, 6, 2, 2, 1, 7]
console.timeEnd();


// solution

// 테스트 1 〉	통과 (0.29ms, 33.6MB)
// 테스트 2 〉	통과 (0.30ms, 33.7MB)
// 테스트 3 〉	통과 (0.30ms, 33.7MB)
// 테스트 4 〉	통과 (0.13ms, 33.6MB)
// 테스트 5 〉	통과 (0.13ms, 33.7MB)
// 테스트 6 〉	통과 (0.14ms, 33.7MB)
// 테스트 7 〉	통과 (0.32ms, 33.6MB)
// 테스트 8 〉	통과 (0.30ms, 33.6MB)
// 테스트 9 〉	통과 (0.31ms, 33.6MB)
// 테스트 10 〉	통과 (0.30ms, 33.6MB)
// 테스트 11 〉	통과 (0.26ms, 33.7MB)
// 테스트 12 〉	통과 (0.28ms, 33.6MB)


// solution2

// 테스트 1 〉	통과 (0.15ms, 33.4MB)
// 테스트 2 〉	통과 (0.20ms, 33.4MB)
// 테스트 3 〉	통과 (0.14ms, 33.4MB)
// 테스트 4 〉	통과 (0.06ms, 33.4MB)
// 테스트 5 〉	통과 (0.09ms, 33.4MB)
// 테스트 6 〉	통과 (0.07ms, 33.4MB)
// 테스트 7 〉	통과 (0.14ms, 33.5MB)
// 테스트 8 〉	통과 (0.15ms, 33.5MB)
// 테스트 9 〉	통과 (0.14ms, 33.5MB)
// 테스트 10 〉	통과 (0.16ms, 33.5MB)
// 테스트 11 〉	통과 (0.07ms, 33.4MB)
// 테스트 12 〉	통과 (0.07ms, 33.5MB)


// solution3

// 테스트 1 〉	통과 (0.08ms, 33.4MB)
// 테스트 2 〉	통과 (0.16ms, 33.4MB)
// 테스트 3 〉	통과 (0.16ms, 33.4MB)
// 테스트 4 〉	통과 (0.07ms, 33.4MB)
// 테스트 5 〉	통과 (0.06ms, 33.4MB)
// 테스트 6 〉	통과 (0.07ms, 33.4MB)
// 테스트 7 〉	통과 (0.16ms, 33.5MB)
// 테스트 8 〉	통과 (0.16ms, 33.3MB)
// 테스트 9 〉	통과 (0.17ms, 33.4MB)
// 테스트 10 〉	통과 (0.16ms, 33.4MB)
// 테스트 11 〉	통과 (0.08ms, 33.4MB)
// 테스트 12 〉	통과 (0.08ms, 33.5MB)


// solution4

// 테스트 1 〉	통과 (0.06ms, 33.4MB)
// 테스트 2 〉	통과 (0.14ms, 33.5MB)
// 테스트 3 〉	통과 (0.14ms, 33.4MB)
// 테스트 4 〉	통과 (0.05ms, 33.4MB)
// 테스트 5 〉	통과 (0.05ms, 33.4MB)
// 테스트 6 〉	통과 (0.05ms, 33.4MB)
// 테스트 7 〉	통과 (0.14ms, 33.4MB)
// 테스트 8 〉	통과 (0.14ms, 33.4MB)
// 테스트 9 〉	통과 (0.14ms, 33.4MB)
// 테스트 10 〉	통과 (0.14ms, 33.6MB)
// 테스트 11 〉	통과 (0.06ms, 33.5MB)
// 테스트 12 〉	통과 (0.11ms, 33.6MB)
