/**
 * 수열과 구간 쿼리 4
 * 
 * 정수 배열 arr와 2차원 정수 배열 queries이 주어집니다. 
 * queries의 원소는 각각 하나의 query를 나타내며, [s, e, k] 꼴입니다.
 * 각 query마다 순서대로 s ≤ i ≤ e인 모든 i에 대해 i가 k의 배수이면 arr[i]에 1을 더합니다.
 * 위 규칙에 따라 queries를 처리한 이후의 arr를 return 하는 solution 함수를 완성해 주세요.
 */

const solution = (arr, queries) => queries.reduce((acc, [s, e, k]) => acc.map((n, i) => s<=i && i<=e && !(i%k) ? n+=1 : n), arr);

console.log(solution([0,1,2,4,3], [[0, 4, 1],[0, 3, 2],[0, 3, 3]]));    // [3, 2, 4, 6, 4]


// map 안에서는 증강연산자가 안 됨.

// 결과
// 테스트 1 〉	통과 (14.10ms, 36.8MB)
// 테스트 2 〉	통과 (7.35ms, 36.6MB)
// 테스트 3 〉	통과 (2.27ms, 35.9MB)
// 테스트 4 〉	통과 (0.45ms, 33.6MB)
// 테스트 5 〉	통과 (0.44ms, 33.6MB)
// 테스트 6 〉	통과 (0.10ms, 33.6MB)
// 테스트 7 〉	통과 (8.21ms, 36.9MB)
// 테스트 8 〉	통과 (11.12ms, 36.7MB)
// 테스트 9 〉	통과 (5.61ms, 36.6MB)
// 테스트 10 〉	통과 (15.55ms, 36.8MB)
// 테스트 11 〉	통과 (8.16ms, 36.6MB)

// 재귀를 통해 보통 n2의 속도를 n으로 높임 => 근데 실상은 높아지지 않음;;
// 한 줄로 요약
// 매개변수에 대한 오류처리
// 결론적으로 보기도 힘들고 속도도 느리고 메모리 효율도 좋지 않음...
// const solution=(a,q)=>q.length?solution(a.map((v,i)=>i>=q[0][0]&&i<=q[0][1]&&!(i%q[0][2])?v+1:v),q.slice(1)):a

// 테스트 1 〉	통과 (23.19ms, 50.6MB)
// 테스트 2 〉	통과 (14.22ms, 38.3MB)
// 테스트 3 〉	통과 (4.35ms, 36.3MB)
// 테스트 4 〉	통과 (1.85ms, 35.5MB)
// 테스트 5 〉	통과 (0.70ms, 33.6MB)
// 테스트 6 〉	통과 (0.12ms, 33.5MB)
// 테스트 7 〉	통과 (12.17ms, 43.3MB)
// 테스트 8 〉	통과 (22.46ms, 42.9MB)
// 테스트 9 〉	통과 (7.33ms, 39.3MB)
// 테스트 10 〉	통과 (17.81ms, 43.3MB)
// 테스트 11 〉	통과 (12.08ms, 42.5MB)


// 일반적인 for문을 이용한 처리 => 원초적으로 갈수록 처리속도는 빨라짐
// 결과적으로 가장 빠른 속도를 보여줌.
// function solution(arr, queries) {
//     for(let [s, e, k] of queries) {
//         for(let i = s; i <= e; i++) {
//             if(i % k === 0) arr[i]++;
//         }
//     }
//     return arr;
// }

// 테스트 1 〉	통과 (5.05ms, 37.1MB)
// 테스트 2 〉	통과 (7.59ms, 36.8MB)
// 테스트 3 〉	통과 (0.54ms, 33.7MB)
// 테스트 4 〉	통과 (0.21ms, 33.6MB)
// 테스트 5 〉	통과 (0.23ms, 33.6MB)
// 테스트 6 〉	통과 (0.15ms, 33.5MB)
// 테스트 7 〉	통과 (5.13ms, 37.1MB)
// 테스트 8 〉	통과 (6.06ms, 36.9MB)
// 테스트 9 〉	통과 (4.26ms, 37MB)
// 테스트 10 〉	통과 (4.39ms, 36.9MB)
// 테스트 11 〉	통과 (4.94ms, 36.9MB)


// 향상된 for문 제거
// 결과적으로 좀 더 원초적으로 갈수록 속도는 빨라짐.
// 뿐문아니라 메모리 효율도 좋아짐.
// function solution(arr, queries) {
//     for(let j = 0; j < queries.length; j++) {
//         for(let i = queries[j][0]; i <= queries[j][1]; i++) {
//             if(i % queries[j][2] === 0) arr[i]++;
//         }
//     }
//     return arr;
// }

// 테스트 1 〉	통과 (2.69ms, 37MB)
// 테스트 2 〉	통과 (4.51ms, 36.9MB)
// 테스트 3 〉	통과 (1.83ms, 36.8MB)
// 테스트 4 〉	통과 (0.26ms, 33.5MB)
// 테스트 5 〉	통과 (0.23ms, 33.6MB)
// 테스트 6 〉	통과 (0.15ms, 33.6MB)
// 테스트 7 〉	통과 (4.53ms, 37MB)
// 테스트 8 〉	통과 (4.68ms, 37.1MB)
// 테스트 9 〉	통과 (2.87ms, 36.8MB)
// 테스트 10 〉	통과 (3.06ms, 36.9MB)
// 테스트 11 〉	통과 (4.46ms, 36.8MB)



// 첫 번째 for문을 재귀함수로 변경했을 때,
// 위의 2중 for문 보다 속도측면에서 효율이 더 악화됨.
// function solution(arr, queries) {
//     if(queries.length) {
//         solution(arr, queries.slice(1));

//         for(let i = queries[0][0]; i <= queries[0][1]; i++) {
//             if(i % queries[0][2] === 0) arr[i]++;
//         }
//     } 

//     return arr;
// }

// 테스트 1 〉	통과 (13.41ms, 36MB)
// 테스트 2 〉	통과 (4.56ms, 34MB)
// 테스트 3 〉	통과 (1.18ms, 33.9MB)
// 테스트 4 〉	통과 (0.31ms, 33.6MB)
// 테스트 5 〉	통과 (0.26ms, 33.5MB)
// 테스트 6 〉	통과 (0.13ms, 33.6MB)
// 테스트 7 〉	통과 (8.80ms, 36.9MB)
// 테스트 8 〉	통과 (10.58ms, 36MB)
// 테스트 9 〉	통과 (4.17ms, 34.5MB)
// 테스트 10 〉	통과 (13.00ms, 35.9MB)
// 테스트 11 〉	통과 (6.40ms, 34.6MB)



// 모든 for문을 지우고, 재귀로만 구성하였을 때,
// 메모리의 효율은 매우 떨어지지만
// 속도적인 측면에서 효율이 좋아짐.
// function solution(arr, queries) {
//     if(queries.length) {
//         solution(arr, queries.slice(1));
//         plusArr(arr, queries[0][0], queries[0][1], queries[0][2])
//     } 

//     return arr;
// }

// function plusArr(arr, s, e, k) {
//     if(s <= e) {
//         plusArr(arr, s+1, e, k);
//         if(s % k === 0) arr[s]++;
//     }
// }

// 테스트 1 〉	통과 (5.00ms, 38.2MB)
// 테스트 2 〉	통과 (2.93ms, 36.1MB)
// 테스트 3 〉	통과 (1.06ms, 35.9MB)
// 테스트 4 〉	통과 (0.22ms, 33.6MB)
// 테스트 5 〉	통과 (0.23ms, 33.5MB)
// 테스트 6 〉	통과 (0.06ms, 33.6MB)
// 테스트 7 〉	통과 (5.70ms, 38.8MB)
// 테스트 8 〉	통과 (5.95ms, 37.9MB)
// 테스트 9 〉	통과 (2.75ms, 36.4MB)
// 테스트 10 〉	통과 (4.91ms, 37.8MB)
// 테스트 11 〉	통과 (2.61ms, 36.7MB)



// 결론적으로 원초적인 2중 for문이 가장 효율이 좋은 것으로 확인됨.